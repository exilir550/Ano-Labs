const fs = require("fs-extra");
const path = require("path");
const cloudinary = require("cloudinary").v2;
require("dotenv").config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

const IMAGES_DIR = path.join(__dirname, "images");
const METADATA_DIR = path.join(__dirname, "metadata");

async function uploadImagesAndGenerateMetadata() {
  const files = await fs.readdir(IMAGES_DIR);
  await fs.ensureDir(METADATA_DIR);

  let index = 0;

  for (const file of files) {
    const filePath = path.join(IMAGES_DIR, file);
    if (!/\.(jpg|jpeg|png|gif|webp)$/i.test(file)) continue;

    console.log(`üì§ Uploading: ${file}`);
    try {
      // Upload image to Cloudinary
      const upload = await cloudinary.uploader.upload(filePath, {
        folder: "ano-nfts",
        use_filename: true,
        unique_filename: false,
        overwrite: true,
      });

      const imageUrl = upload.secure_url;

      // Use sequential tokenId as filename
      const tokenId = index.toString();

      // Create metadata
      const metadata = {
        name: file.replace(/\.[^/.]+$/, ""),
        description: "NFT generated by Ano Labs",
        image: imageUrl,
      };

      // Save metadata locally
      const metadataPath = path.join(METADATA_DIR, `${tokenId}.json`);
      await fs.writeJson(metadataPath, metadata, { spaces: 2 });

      // Upload metadata to Cloudinary
      const metaUpload = await cloudinary.uploader.upload(metadataPath, {
        resource_type: "raw",
        folder: "metadata",
        use_filename: true,
        unique_filename: false,
        overwrite: true,
      });

      console.log("‚úÖ Uploaded image:", imageUrl);
      console.log("üßæ Metadata file:", metaUpload.secure_url);
      console.log("-----------");

      index++;
    } catch (err) {
      console.error("‚ùå Failed to upload", file, err.message);
    }
  }
}

uploadImagesAndGenerateMetadata();
